# A87: CH1 Relay On/Off Status (id=2583, alias=30, io=Output, tsType=2, value=0)
# C42: (not RT310) Hot Water Mode(Auto, Once, On or Off) (id=2625, alias=67, io=Output, tsType=2)
# A88: CH1 Auto Mode (0) or Temp Hold Mode (1) (id=2587, alias=31, io=Output, tsType=2, value=0)
# A00: CH1 Program Mon (CCTTCCTT…) (id=2604, alias=20, io=Output, tsType=0, value=90F5;0F5=0F5>0F5@0F5G0F0)
# A89: CH1 Off Mode (1) (id=2588, alias=32, io=Output, tsType=2, value=0)
# C00: (not RT310) Hot Water Program Mon (CCCC…) (id=2618, alias=60, io=Output, tsType=0)
# C44: (not RT310) Hot Water Schedule Type(All, 5/2 or Independent) (id=2627, alias=69, io=Output, tsType=2)
# A01: CH1 Program Tue (CCTTCCTT…) (id=2556, alias=21, io=Output, tsType=0, value=90F5;0F5=0F5>0F5@0F5G0F0)
# A02: CH1 Program Wed (CCTTCCTT…) (id=2602, alias=22, io=Output, tsType=0, value=90F5;0F5=0F5>0F5@0F5G0F0)
# C43: (not RT310) Hot Water Boost Remaning Hours(0 - 9) (id=2626, alias=68, io=Output, tsType=2)
# A03: CH1 Program Thu (CCTTCCTT…) (id=2595, alias=23, io=Output, tsType=0, value=90F5;0F5=0F5>0F5@0F5G0F0)
# C02: (not RT310) Hot Water Program Wed (CCCC…) (id=2620, alias=62, io=Output, tsType=0)
# C46: (not RT310) Hot Water Running Auto Mode (0) or Manual Mode (1) (id=2629, alias=71, io=Output, tsType=2)
# A04: CH1 Program Fri (CCTTCCTT…) (id=2600, alias=24, io=Output, tsType=0, value=90F5;0F5=0F5>0F5@0F5G0F0)
# C01: (not RT310) Hot Water Program Tue (CCCC…) (id=2619, alias=61, io=Output, tsType=0)
# C45: (not RT310) Hot Water On/Off Status (id=2628, alias=70, io=Output, tsType=2)
# A05: CH1 Program Sat (CCTTCCTT…) (id=2601, alias=25, io=Output, tsType=0, value=90F5;0F5=0F5>0F5@0F5G0F0)
# C04: (not RT310) Hot Water Program Fri (CCCC…) (id=2622, alias=64, io=Output, tsType=0)
# A06: CH1 Program Sun (CCTTCCTT…) (id=2598, alias=26, io=Output, tsType=0, value=90F5;0F5=0F5>0F5@0F5G0F0)
# C03: (not RT310) Hot Water Program Thu (CCCC…) (id=2621, alias=63, io=Output, tsType=0)
# C06: (not RT310) Hot Water Program Sun (CCCC…) (id=2624, alias=66, io=Output, tsType=0)
# C05: (not RT310) Hot Water Program Sat (CCCC…) (id=2623, alias=65, io=Output, tsType=0)
# FSTART: Firmware Download (id=2558, alias=0, io=Output, tsType=0)
# S00: OTA Status - OTA(1) No OTA(0) (id=2580, alias=100, io=Output, tsType=0, value=0)
# S02: Upgrade Available (id=2596, alias=102, io=Output, tsType=0)
# S01: Energy Save Status(On or Off) (id=2603, alias=101, io=Output, tsType=2, value=0)
# S04: Time Zone (id=2559, alias=104, io=Output, tsType=2, value=2)
# S03: Battery Status (id=2597, alias=103, io=Output, tsType=2, value=0)
# S06: System Type (CH1, CH1+CH2 or CH1 + Hot Water) (id=2562, alias=106, io=Output, tsType=2, value=0)
# A90: CH1 Frost Active(1)/Inactive(0) (id=2565, alias=33, io=Output, tsType=2, value=0)
# A91: CH1 Boost Remaining hours (id=2564, alias=34, io=Output, tsType=10, value=0)
# S05: System Mode (Heating or Cooling) (id=2599, alias=105, io=Output, tsType=2, value=0)
# A92: CH1 Manual Mode (1) (id=2579, alias=35, io=Output, tsType=1, value=1)
# S08: Hour Format Option:12 or 24 (id=2591, alias=108, io=Output, tsType=2, value=1)
# S07: Temp Unit (C or F) (id=2563, alias=107, io=Output, tsType=2, value=0)
# A93: CH1 Manual Mode Setpoint (id=2635, alias=36, io=Output, tsType=4, value=1800)
# A94: CH1 Auto Mode Setpoint (id=2636, alias=37, io=Output, tsType=4)
# S09: Frost Temperature (x 0.01C) (id=2592, alias=109, io=Output, tsType=3, value=900)
# sys-reboot: Reboot CC1110 of Thermostat (id=2566, alias=0, io=Output, tsType=4, value=1)
# baud: UART Baud-Rate (id=2581, alias=0, io=Output, tsType=0)
# version: CC1110 Firmware Version (id=2557, alias=0, io=Input, tsType=0, value=1.5.2.0 (Mar 28 2017))
# S11: Holiday Start (YYYYMMDDHHMM) (id=2572, alias=111, io=Output, tsType=0, value=201501010000)
# S10: Holiday Option (On or Off) (id=2573, alias=110, io=Output, tsType=2, value=0)
# S13: Thermostat Microprocessor Version (id=2570, alias=113, io=Output, tsType=0, value=11.5)
# S12: Holiday End (YYMMDDHHMM) (id=2571, alias=112, io=Output, tsType=0, value=201501010000)
# S15: Span (0-> +/-0.5, 1-> +/-0.25) (id=2690, alias=115, io=Output, tsType=2, value=0)
# S14: Daylight Saving Time (0 -> On / 1 -> Off) (id=2575, alias=114, io=Output, tsType=2, value=0)
# S17: Display offset (-3C ~ 3C) ( 0->-3C, 12->3C) (id=2693, alias=117, io=Output, tsType=2, value=6)
# S16: Display tolerance (0->0.5C, 1->0.1C) (id=2691, alias=116, io=Output, tsType=2, value=0)
# S19: Delay Start Enable (1 Enable, 0 Disable) (id=3041, alias=119, io=Output, tsType=2, value=0)
# Rule: Geolocation Behavior Rule (id=3042, alias=0, io=Output, tsType=0)
# B84: (not RT310) CH2 Current Room Temperature (x 0.01C) (id=2613, alias=47, io=Output, tsType=3)
# desc: Description (id=2590, alias=0, io=Output, tsType=0, value=Vigomlya)
# B85: (not RT310) CH2 Current Setpoint (x 0.01C) (id=2614, alias=48, io=Output, tsType=3)
# B86: (not RT310) CH2 Schedule Type(All, 5/2 or Independent) (id=2615, alias=49, io=Output, tsType=2)
# B87: (not RT310)  CH2 Relay On/Off Status (id=2616, alias=50, io=Output, tsType=2)
# B00: (not RT310) CH2 Program Mon (CCTTCCTT…) (id=2606, alias=40, io=Output, tsType=0)
# B88: (not RT310) CH2 Auto Mode (0) or Temp Hold Mode (1) (id=2617, alias=51, io=Output, tsType=2)
# B01: (not RT310) CH2 Program Tue (CCTTCCTT…) (id=2607, alias=41, io=Output, tsType=0)
# B89: (not RT310) CH2 Off Mode (1) (id=2630, alias=52, io=Output, tsType=2)
# B02: (not RT310) CH2 Program Wed (CCTTCCTT…) (id=2608, alias=42, io=Output, tsType=0)
# B03: (not RT310) CH2 Program Thu (CCTTCCTT…) (id=2609, alias=43, io=Output, tsType=0)
# F: Turn On Refresh Mode for X Seconds (Recommend X=60) (id=2568, alias=80, io=Output, tsType=0, value=60)
# B04: (not RT310) CH2 Program Fri (CCTTCCTT…) (id=2610, alias=44, io=Output, tsType=0)
# B05: (not RT310) CH2 Program Sat (CCTTCCTT…) (id=2611, alias=45, io=Output, tsType=0)
# B06: (not RT310) CH2 Program Sun (CCTTCCTT…) (id=2612, alias=46, io=Output, tsType=0)
# imsg: iPhone OTA user messages (id=2567, alias=0, io=Output, tsType=0)
# rfrssi: rfrssi Signal Strength (id=2560, alias=0, io=Output, tsType=0, value=1)
# sys-program: Upgrade CC1110 Firmware (id=2569, alias=0, io=Output, tsType=0)
# Phone1: Phone1 (id=3148, alias=0, io=Output, tsType=0)
# Phone3: Phone3 (id=3150, alias=0, io=Output, tsType=0)
# dlcsum: Download Checksum (id=2589, alias=0, io=Output, tsType=4)
# Phone2: Phone2 (id=3149, alias=0, io=Output, tsType=0)
# Phone5: Phone5 (id=3152, alias=0, io=Output, tsType=0)
# Phone4: Phone4 (id=3151, alias=0, io=Output, tsType=0)
# Phone7: Phone7 (id=3154, alias=0, io=Output, tsType=0)
# B90: (not RT310) CH2 Frost Active(1)/Inactive(0) (id=2631, alias=53, io=Output, tsType=2)
# Phone6: Phone6 (id=3153, alias=0, io=Output, tsType=0)
# B91: (not RT310) CH2 Boost Remaining hours (id=2632, alias=54, io=Output, tsType=10)
# B92: (not RT310) CH2 Manual Mode (1) (id=2633, alias=55, io=Output, tsType=1)
# Phone8: Phone8 (id=3155, alias=0, io=Output, tsType=0)
# sys-pm: sys-pm (id=2561, alias=0, io=Output, tsType=4)
# sys-aeskey: Arrayent Use Only (id=2634, alias=0, io=Output, tsType=0)
# online: Device Online/Offline Status (id=2578, alias=0, io=Output, tsType=1, value=1)
# mftc: Manufacturing Programming Complete (mftc) (id=2593, alias=81, io=Output, tsType=2)
# A84: CH1 Current Room Temperature (x 0.01C) (id=2584, alias=27, io=Output, tsType=3, value=1822)
# A85: CH1 Current Setpoint (x 0.01C) (id=2585, alias=28, io=Output, tsType=3, value=1800)
# A86: CH1 Schedule Type(All, 5/2 or Independent) (id=2582, alias=29, io=Output, tsType=2, value=0)
# updVersion2: Lapis Processor New Version (id=2574, alias=0, io=Output, tsType=0, attrValue=10.9, value=10.9)
# updFileId1: File ID of Radio Firmware (id=2586, alias=0, io=Output, tsType=3, attrValue=1518, value=1518)
# updVersion1: Radio Firmware New Version (id=2605, alias=0, io=Output, tsType=0, attrValue=1.5.1.8 (Nov 24 2016), value=1.5.1.8 (Nov 24 2016))
# updDlcsum2: Lapis Processor Download Checksum (id=2577, alias=0, io=Output, tsType=3, attrValue=57222, value=57222)
# updFileId2: Lapis Process File ID (id=2594, alias=0, io=Output, tsType=3, attrValue=310109, value=310109)
# updDlcsum1: Radio Firmware Download Checksum (id=2576, alias=0, io=Output, tsType=3, attrValue=943, value=943)



import requests
import hashlib
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Iterator, List, Optional

BASE_URL = "https://sal-emea-p01-api.arrayent.com"
ZDK = f"{BASE_URL}/zdk/services/zamapi"
SESS = f"{BASE_URL}/acc/applications/SalusService/sessions"

HEADERS_JSON = {
    "Accept": "application/json",
    "Content-Type": "application/json",
}

HEADERS_FORM = {
    "Accept": "application/xml",
    "Content-Type": "application/x-www-form-urlencoded",
    "User-Agent": "HA-SalusLib/1.1",
}


class InvalidCredentialsError(RuntimeError):
    """Raised when credentials are rejected by the Salus API."""


def _strip_ns(root: ET.Element) -> ET.Element:
    """Remove namespaces from XML tree for easy searching."""
    for el in root.iter():
        if isinstance(el.tag, str) and "}" in el.tag:
            el.tag = el.tag.split("}", 1)[1]
    return root


def _coerce_value(text: Optional[str]) -> Any:
    """Best-effort coercion of attribute values into native Python types."""
    if text is None:
        return None
    value = text.strip()
    if value == "":
        return ""

    lowered = value.lower()
    if lowered in {"true", "false"}:
        return lowered == "true"
    if lowered in {"yes", "no"}:
        return lowered == "yes"

    try:
        if "." in value or "e" in lowered:
            number = float(value)
            return int(number) if number.is_integer() else number
        return int(value)
    except ValueError:
        return value


def _coerce_bool(text: Optional[str]) -> bool:
    """Convert textual booleans (and 0/1) to Python bool."""
    if text is None:
        return False
    lowered = text.strip().lower()
    return lowered in {"1", "true", "yes"}


def _coerce_int(text: Optional[str]) -> Optional[int]:
    """Convert textual integers to Python int."""
    if text is None:
        return None
    try:
        return int(text.strip())
    except (TypeError, ValueError):
        return None


@dataclass(slots=True)
class DeviceAttribute:
    """Structured representation of a device attribute."""

    id: int
    name: str
    display_name: str
    device: bool
    persistent: bool
    timestamped: bool
    global_scope: bool
    ts_value_type: Optional[int]
    hardware_io_type: str
    enumerated_alias: Optional[int]
    value: Any
    raw_value: Any
    updated_at_ms: Optional[int]
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def updated_at(self) -> Optional[datetime]:
        """Return update timestamp as datetime if available."""
        if self.updated_at_ms is None:
            return None
        try:
            return datetime.fromtimestamp(self.updated_at_ms / 1000)
        except (OSError, OverflowError, ValueError):
            return None

    def as_bool(self) -> Optional[bool]:
        """Interpret value as boolean when applicable."""
        if isinstance(self.value, bool):
            return self.value
        if isinstance(self.value, (int, float)):
            return bool(self.value)
        if isinstance(self.value, str):
            lowered = self.value.strip().lower()
            if lowered in {"1", "true", "yes"}:
                return True
            if lowered in {"0", "false", "no"}:
                return False
        return None

    def as_number(self) -> Optional[float]:
        """Interpret value as numeric when possible."""
        if isinstance(self.value, (int, float)):
            return float(self.value)
        if isinstance(self.value, str):
            try:
                return float(self.value)
            except ValueError:
                return None
        return None


class Attributes:
    """Container for device attributes with fast lookup helpers."""

    def __init__(self, items: List[DeviceAttribute]) -> None:
        self._items = items
        self._by_name: Dict[str, DeviceAttribute] = {
            attr.name: attr for attr in items if attr.name
        }
        self._by_id: Dict[int, DeviceAttribute] = {attr.id: attr for attr in items}

    def __iter__(self) -> Iterator[DeviceAttribute]:
        return iter(self._items)

    def __len__(self) -> int:
        return len(self._items)

    def __getitem__(self, index: int) -> DeviceAttribute:
        return self._items[index]

    def get(self, name: str) -> Optional[DeviceAttribute]:
        """Return attribute by name."""
        return self._by_name.get(name)

    def get_by_id(self, attr_id: int) -> Optional[DeviceAttribute]:
        """Return attribute by numeric id."""
        return self._by_id.get(attr_id)

    def values(self) -> List[DeviceAttribute]:
        """Return a copy of the underlying list."""
        return list(self._items)


def _parse_attribute_node(node: ET.Element) -> DeviceAttribute:
    """Convert an attrList XML node into a DeviceAttribute instance."""
    metadata: Dict[str, Any] = {}
    for child in list(node):
        tag = child.tag
        metadata[tag] = child.text

    attr_id = _coerce_int(node.findtext("id")) or 0
    name = (node.findtext("name") or "").strip()
    display_name = (node.findtext("displayName") or "").strip()

    device = _coerce_bool(node.findtext("device"))
    persistent = _coerce_bool(node.findtext("presistent"))
    timestamped = _coerce_bool(node.findtext("ts"))
    global_scope = _coerce_bool(node.findtext("global"))
    ts_value_type = _coerce_int(node.findtext("tsValueType"))
    hardware_io_type = (node.findtext("hardwareIOType") or "").strip()
    enumerated_alias = _coerce_int(node.findtext("enumeratedAlias"))

    value_text = node.findtext("value")
    attr_value_text = node.findtext("attrValue")
    value = _coerce_value(value_text)
    raw_value = value_text if value_text is not None else attr_value_text
    if raw_value is None and attr_value_text is not None:
        value = _coerce_value(attr_value_text)

    upd_time = _coerce_int(node.findtext("updTime"))

    return DeviceAttribute(
        id=attr_id,
        name=name,
        display_name=display_name,
        device=device,
        persistent=persistent,
        timestamped=timestamped,
        global_scope=global_scope,
        ts_value_type=ts_value_type,
        hardware_io_type=hardware_io_type,
        enumerated_alias=enumerated_alias,
        value=value,
        raw_value=raw_value,
        updated_at_ms=upd_time,
        metadata=metadata,
    )


class DeviceCollection:
    """Container for SalusDevice objects with lookup helpers."""

    def __init__(self, items: List["SalusDevice"]) -> None:
        self._items = items
        self._by_id: Dict[str, "SalusDevice"] = {
            device.dev_id: device for device in items if device.dev_id
        }
        self._by_name: Dict[str, "SalusDevice"] = {}
        for device in items:
            if device.name and device.name not in self._by_name:
                self._by_name[device.name] = device

    def __iter__(self) -> Iterator["SalusDevice"]:
        return iter(self._items)

    def __len__(self) -> int:
        return len(self._items)

    def __getitem__(self, index: int) -> "SalusDevice":
        return self._items[index]

    def find_by_id(self, dev_id: str) -> Optional["SalusDevice"]:
        """Return the device with the specified identifier."""
        return self._by_id.get(dev_id)

    def find_by_name(self, name: str) -> Optional["SalusDevice"]:
        """Return the first device with the specified name."""
        return self._by_name.get(name)

    def values(self) -> List["SalusDevice"]:
        """Return a copy of the underlying device list."""
        return list(self._items)


class SalusDevice:
    """Represents a single Salus device."""

    ATTR_ONLINE = "online"
    ATTR_ROOM_TEMPERATURE = "A84"
    ATTR_SETPOINT = "A85"
    ATTR_AUTO_MODE = "A88"
    ATTR_OFF_MODE = "A89"
    ATTR_RELAY_STATUS = "A87"
    ATTR_SIGNAL_STRENGTH = "rfrssi"
    ATTR_MANUAL_MODE = "A92"
    DEFAULT_ATTRIBUTE_TTL_MS = 1000

    def __init__(
        self,
        api: "SalusAPI",
        dev_id: str,
        device_type_id: str,
        name: str,
        type_name: str | None = None,
        type_display_name: str | None = None,
        sleep_mode: str | None = None,
        app_id: str | None = None,
        user_id: str | None = None,
    ):
        self.api = api
        self.dev_id = dev_id
        self.device_type_id = device_type_id
        self.name = name
        self.type_name = (type_name or "").strip()
        self.type_display_name = (type_display_name or "").strip()
        self.sleep_mode = (sleep_mode or "").strip()
        self.app_id = (app_id or "").strip()
        self.user_id = (user_id or "").strip()
        self._attributes: Optional[Attributes] = None
        self._attributes_updated_at: Optional[datetime] = None
        self.attribute_ttl_ms: int = self.DEFAULT_ATTRIBUTE_TTL_MS

    def fetch_attributes(self) -> Attributes:
        """Fetch attributes from the cloud and cache them on the device."""
        attrs = self.api.get_attributes(self.dev_id, self.device_type_id)
        self._attributes = attrs
        self._attributes_updated_at = datetime.now(timezone.utc)
        return attrs

    def get_attributes(self) -> Attributes:
        """Return cached attributes, fetching them if necessary."""
        if self._attributes is None or self._attributes_expired:
            return self.fetch_attributes()
        return self._attributes

    def get_attribute(self, name: str) -> Optional[DeviceAttribute]:
        """Return a specific attribute by name, fetching if required."""
        attrs = self.get_attributes()
        return attrs.get(name)

    def get_attribute_value(self, name: str) -> Any:
        """Return the value portion of an attribute by name."""
        attr = self.get_attribute(name)
        return attr.value if attr else None

    @property
    def get_online_status(self) -> Optional[bool]:
        """Return device online status as boolean when available."""
        attr = self.get_attribute(self.ATTR_ONLINE)
        return attr.as_bool() if attr else None

    @property
    def get_room_temperature(self) -> Optional[float]:
        """Return current room temperature in °C."""
        attr = self.get_attribute(self.ATTR_ROOM_TEMPERATURE)
        if not attr:
            return None
        number = attr.as_number()
        if number is None:
            return None
        # Value reported in hundredths of a degree Celsius.
        return number / 100 if number is not None else None

    @property
    def get_set_point_temperature(self) -> Optional[float]:
        """Return current set point temperature in °C."""
        attr = self.get_attribute(self.ATTR_SETPOINT)
        if not attr:
            return None
        number = attr.as_number()
        if number is None:
            return None
        return number / 100

    @property
    def get_relay_active(self) -> Optional[bool]:
        """Return whether CH1 relay is active."""
        attr = self.get_attribute(self.ATTR_RELAY_STATUS)
        if not attr:
            return None
        value = attr.as_bool()
        if value is not None:
            return value
        number = attr.as_number()
        return bool(number) if number is not None else None

    @property
    def get_signal_level(self) -> Optional[str]:
        """Return radio signal strength information."""
        attr = self.get_attribute(self.ATTR_SIGNAL_STRENGTH)
        if not attr:
            return None
        # Signal strength typically provided as string (e.g. "-68 0")
        if isinstance(attr.raw_value, str):
            return attr.raw_value.strip()
        if isinstance(attr.value, str):
            return attr.value.strip()
        if attr.as_number() is not None:
            return str(int(attr.as_number() or 0))
        return None

    @property
    def get_mode(self) -> Optional[str]:
        """Return current operating mode ('schedule', 'manual', or 'off')."""
        attr_off = self.get_attribute(self.ATTR_OFF_MODE)
        if attr_off:
            off_flag = attr_off.as_bool()
            if off_flag is None:
                off_flag = bool(attr_off.as_number() or 0)
            if off_flag:
                return "off"

        attr_manual = self.get_attribute(self.ATTR_MANUAL_MODE)
        if attr_manual:
            manual_flag = attr_manual.as_bool()
            if manual_flag is None:
                manual_flag = bool(attr_manual.as_number() or 0)
            if manual_flag:
                return "manual"

        attr_auto = self.get_attribute(self.ATTR_AUTO_MODE)
        if attr_auto:
            auto_flag = attr_auto.as_bool()
            if auto_flag is None:
                auto_flag = bool(attr_auto.as_number() or 0)
            if auto_flag:
                return "manual"

        return "schedule"

    @property
    def attributes(self) -> Optional[Attributes]:
        """Return the last cached attributes if available."""
        return self._attributes

    @property
    def _attributes_expired(self) -> bool:
        """Return True if cached attributes are stale."""
        if self._attributes is None or self._attributes_updated_at is None:
            return True
        delta = datetime.now(timezone.utc) - self._attributes_updated_at
        return delta > timedelta(milliseconds=self.attribute_ttl_ms)

    def set_attribute(self, name: str, value: str) -> bool:
        """Set an attribute for this device."""
        return self.api.set_attribute(self.dev_id, self.device_type_id, name, value)

    # Convenience methods for climate integration
    def set_set_point_temperature(self, temp_c: float) -> bool:
        """Set target temperature in °C (A85)."""
        return self.set_attribute("A85", int(temp_c * 100))

    def turn_off(self) -> bool:
        """Turn device OFF (A89 = 1)."""
        return self.set_attribute("A89", 1)

    def turn_on(self) -> bool:
        """Turn device ON (A89 = 0)."""
        return self.set_attribute("A89", 0)

    def set_mode_manual(self) -> bool:
        """Switch to manual mode (A92 = 1)."""
        return self.set_attribute("A92", 1)

    def set_mode_auto(self) -> bool:
        """Switch to auto mode (A92 = 0)."""
        return self.set_attribute("A92", 0)


class SalusAPI:
    """API client for Salus / Arrayent cloud."""

    def __init__(self):
        self.session = requests.Session()
        self.user_id: Optional[str] = None
        self.sec_token: Optional[str] = None
        self.last_device_list_xml: Optional[str] = None
        self._device_collection: Optional[DeviceCollection] = None

    def login(self, username: str, password_plain: str) -> None:
        """Login via JSON endpoint with MD5(password)."""
        pwd_md5 = hashlib.md5(password_plain.encode("utf-8")).hexdigest()

        resp = self.session.post(
            SESS,
            headers=HEADERS_JSON,
            json={"username": username, "password": pwd_md5},
            timeout=20,
        )
        try:
            resp.raise_for_status()
        except requests.HTTPError as err:
            try:
                data = resp.json()
            except ValueError:
                data = None
            if isinstance(data, dict) and data.get("errorCode") == 101:
                message = data.get("errorMessage", "Invalid login name or password.")
                raise InvalidCredentialsError(message) from err
            raise
        data = resp.json()

        if isinstance(data, dict) and data.get("errorCode") == 101:
            message = data.get("errorMessage", "Invalid login name or password.")
            raise InvalidCredentialsError(message)

        raw_user_id = data.get("userId")
        self.user_id = str(raw_user_id) if raw_user_id is not None else None
        self.sec_token = data.get("securityToken") or None

        if not self.user_id or not self.sec_token:
            raise RuntimeError(f"Login failed, response: {data}")

    def fetch_devices(self) -> DeviceCollection:
        """Fetch list of devices as SalusDevice objects."""
        url = f"{ZDK}/getDeviceList"
        data = {"userId": self.user_id, "secToken": self.sec_token}
        resp = self.session.post(url, headers=HEADERS_FORM, data=data, timeout=20)
        resp.raise_for_status()
        self.last_device_list_xml = resp.text
        root = _strip_ns(ET.fromstring(resp.text))

        type_map = {}
        for node in root.findall(".//typeNameList"):
            type_id = (node.findtext("id") or "").strip()
            if not type_id:
                continue
            type_map[type_id] = {
                "type_name": (node.findtext("name") or "").strip(),
                "display_name": (node.findtext("displayName") or "").strip(),
            }

        devices: List[SalusDevice] = []
        for node in root.findall(".//devList") + root.findall(".//deviceList"):
            dev_id = (node.findtext("devId") or "").strip()
            dev_type = (node.findtext("typeId") or node.findtext("deviceTypeId") or "").strip()
            name = (node.findtext("devName") or node.findtext("name") or "").strip()
            sleep_mode = (node.findtext("sleepMode") or "").strip()
            app_id = (node.findtext("appID") or node.findtext("appId") or "").strip()
            owner_user_id = (node.findtext("userID") or node.findtext("userId") or "").strip()
            if dev_id and dev_type:
                type_info = type_map.get(dev_type, {})
                devices.append(
                    SalusDevice(
                        self,
                        dev_id,
                        dev_type,
                        name,
                        type_name=type_info.get("type_name"),
                        type_display_name=type_info.get("display_name"),
                        sleep_mode=sleep_mode,
                        app_id=app_id,
                        user_id=owner_user_id,
                    )
                )
        collection = DeviceCollection(devices)
        self._device_collection = collection
        return collection

    @property
    def devices(self) -> Optional[DeviceCollection]:
        """Return the last fetched device collection, if available."""
        return self._device_collection
    
    # Return all attributes with values for a given device.
    def get_attributes(self, dev_id: str, device_type_id: str) -> Attributes:
        url = f"{ZDK}/getDeviceAttributesWithValues"
        data = {"devId": dev_id, "deviceTypeId": device_type_id, "secToken": self.sec_token}
        resp = self.session.post(url, headers=HEADERS_FORM, data=data, timeout=20)
        
        # Check for HTTP errors status codes.
        resp.raise_for_status()

        root = _strip_ns(ET.fromstring(resp.text))

        attributes = [_parse_attribute_node(node) for node in root.findall(".//attrList")]
        return Attributes(attributes)

    def set_attribute(self, dev_id: str, device_type_id: str, name: str, value: str) -> bool:
        """Set an attribute for a given device."""
        url = f"{ZDK}/setDeviceAttribute"
        data = {
            "devId": dev_id,
            "deviceTypeId": device_type_id,
            "secToken": self.sec_token,
            "name": name,
            "value": str(value),
        }
        resp = self.session.post(url, headers=HEADERS_FORM, data=data, timeout=20)
        resp.raise_for_status()
        return resp.ok
    

  
